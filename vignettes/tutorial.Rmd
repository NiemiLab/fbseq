---
title: "`fbseq` package tutorial"
author: Will Landau
bibliography: bibliography.bib
date: 2015
output: 
  rmarkdown::html_vignette:
    number_sections: true
    pandoc_args: [
      "+RTS", "-K64m",
      "-RTS"]
    toc: true
vignette: >
  \VignetteEngine{knitr::rmarkdown}
  \VignetteIndexEntry{`fbseq` package tutorial}
  \usepackage[utf8]{inputenc}
---

```{r}
library(fbseq)
library(methods)
```

# Introduction

The `fbseq` package fits a hierarchical model to RNA-seq data in (nearly) fully Bayesian fashion. Although it was originally designed to fit RNA-seq data, it can also be used to analyze count data with tens of thousands of response variables and only a handful of observations each.

Please read the model vignette first. An understanding of the underlying hierarchical model is important for understanding how to use this package

# Check your system.

You need to have at least R $\ge$ 3.2.0, along with the R packages `coda`, `methods`, `MASS`, `MCMCpack`, `parallel`, `plyr`, `pracma`, and `knitr`, all are available through the [Comprehensive R Archive Network (CRAN](https://cran.r-project.org/). With those requirements met, you can install `fbseq`, load it in an R session, create input, and analyze output. To actually run the underlying Markov chain Monte Carlo (MCMC) procedure, however, you need access to a machine with a [CUDA-enabled GPU](http://www.nvidia.com/object/cuda_home_new.html), along with the [`fbseqCUDA` package](https://github.com/wlandau/fbseqCUDA). `fbseqCUDA` is the internal engine of `fbseq`, and it is implemented in CUDA to provide necessary acceleration for the MCMC. `fbseq` and `fbseqCUDA` are kept separate for convenience. For example, you can set up input with `fbseq` and without `fbseqCUDA` on a low-end laptop, run the main algorithm remotely with both `fbseq` and `fbseqCUDA` on a CUDA-enabled [cloud computing enterprise](http://www.nvidia.com/object/gpu-cloud-computing-services.html) such as [Amazon Web Services](http://aws.amazon.com/ec2/instance-types/), and analyze the output locally with `fbseq` and without `fbseqCUDA`. See the `fbseqCUDA` installation vignette for more details.

# Install `fbseq`.

## Option 1: install directly from GitHub.

For this option, you need the `devtools` package, available from CRAN or GitHub. Just open R and run 

```{r, eval=F}
library(devtools)
install_github("wlandau/fbseq")
```
and then if you have CUDA,

```{r, eval=F}
install_github("wlandau/fbseqCUDA")
```

## Option 2: install from the source.

Open a command line program such as Terminal in Mac/Linux and enter the following commands.

```
git clone git@github.com:wlandau/fbseq.git
R CMD build fbseq
R CMD INSTALL fbseq_0.0.tar.gz
```

Note: you may have to replace `fbseq_0.0.tar.gz` by the name of whatever tarball comes out of `R CMD build`. 

You can install `fbseqCUDA` next, and the steps are analogous. However, you may have to modify the top of the `src/Makevars` file before running `R CMD build`. See the `fbseqCUDA` package vignette for more detailed installation instructions.


# Workflow overview

A typical workflow only requires a few lines of code. However, it requires an understanding of the S4 classes of this package. The steps are as follows.

## Create a `Scenario` object.

`Scenario` is an S4 class for storing the count data, design matrix, and instructions for calculating posterior probabilities of quantities of interest.

```{r}
str(new("Scenario"))
```

Type `help("Scenario-class")` for details about the slots. When you have these slots ready, use the ``Scenario`` function to create a ``Scenario`` object.

```{r, eval = F}
scenario = Scenario(counts = counts, design = design, contrasts = contrasts, bounds = bounds, propositions = propositions, supplement = supplement)
```

With the exception of `Chain` objects, arguments passed to `Scenario` need to be explicitly passed to their slots. For example,

```{r, eval = F}
scenario = Scenario(counts, design, contrasts, bounds, propositions, supplement)
```

would throw an error.



### Example scenario from @paschold

The package comes with a `Scenario` with data taken from @paschold. The data is from an RNA-sequencing (RNA-seq) data experiment on maize described in the paper.

```{r}
data(paschold)
head(paschold@counts)
```

Here, the genes are rows (response variables) and the columns are RNA-seq libraries (observations, samples of genetic material). Each count is the relative measure of the expression of a gene in a laboratory sample of genetic material. The observations are divided into 4 groups:

- `B73`: maize seedlings from an inbred corn population in Iowa.
- `Mo17`: seedlings from a different inbred corn population in Missouri. 
- `B73xMo17`: hybrid seedlings produced from pollenating `B73` corn plants with `Mo17` pollen. 
- `Mo17xB73`: hybrid seedlings produced from pollenating `Mo17` corn plants with `B73` pollen.

The goal of this scenario is to detect which genes satisfy which of following conditions.

|------------------------------------|----------|--------------------------------------------------| 
| high-parent heterosis, both hybrids |	$\qquad$ | all hybrid counts > `B73` and `Mo17` counts  | 
| low-parent heterosis, both hybrids  |	|  all hybrid counts < `B73` and `Mo17` counts  | 
| high-parent heterosis, `B73xMo17`   |	|  `B73xMo17` counts > `B73` and `Mo17` counts  | 
| low-parent heterosis, `B73xMo17`    |	|  `B73xMo17` counts < `B73` and `Mo17` counts  | 
| high-parent heterosis, `Mo17xB73`   |	|  `Mo17xB73` counts > `B73` and `Mo17` counts  | 
| low-parent heterosis, `Mo17xB73`    |	|  `Mo17xB73` counts < `B73` and `Mo17` counts  | 

To translate this problem into a `Scenario`, we use the design matrix,

```{r}
paschold@design
```

In words, the main effect parameters are $\beta_{\ell, g}$ for effect $\ell = 1, \ldots, L = 5$ and $g = 1, \ldots, G = 39656$, and they describe linear combinations of the libraries within a gene. In the following table, a logarithmic scale is used for the interpretations.

|------------------------------------|----------|--------------------------------------------------| 
| $\beta_{1, g}$  |	$\qquad$ | mean of `B73` and `Mo17`  | 
| $\beta_{2, g}$ |	|  half the difference between `Mo17` and the hybrids  | 
| $\beta_{3, g}$   |	| half the difference between `B73` and the hybrids  | 
|$\beta_{4, g}$   |	| difference between `B73xMo17` and `Mo17xB73` | 
|$\beta_{5, g}$   |	|  experimental block effect  | 

With these interpretations, the table of conditions becomes

|------------------------------------|----------|--------------------------------------------------| 
| high-parent heterosis, both hybrids |	$\qquad$ |  $\beta_{2, g} > 0$ and $\beta_{3, g} > 0$ | 
| low-parent heterosis, both hybrids  |	|   $-\beta_{2, g} > 0$ and $-\beta_{3, g} > 0$ | 
| high-parent heterosis, `B73xMo17`   |	|  $2\beta_{2, g} + \beta_{4, g} > 0$ and $2\beta_{3, g} + \beta_{4, g} > 0$  | 
| low-parent heterosis, `B73xMo17`    |	| $-2\beta_{2, g} - \beta_{4, g} > 0$ and $-2\beta_{3, g} - \beta_{4, g} > 0$ | 
| high-parent heterosis, `Mo17xB73`   |	|  $2\beta_{2, g} - \beta_{4, g} > 0$ and $2\beta_{3, g} - \beta_{4, g} > 0$  | 
| low-parent heterosis, `Mo17xB73`    |	| $-2\beta_{2, g} + \beta_{4, g} > 0$ and $-2\beta_{3, g} + \beta_{4, g} > 0$ | 

Each linear combination of the $\beta_{\ell, g}$'s is a contrast, and each row of the table is a logical proposition. We want a posterior probability for each proposition. Hence, the Paschold scenario has the 12 contrasts,

```{r}
paschold@contrasts
```

the lower bounds in the inequalities (all zero),

```{r}
paschold@bounds
```

and the 6 logical propositions we care about, expressed in terms of the indices of the contrasts above.

```{r}
paschold@propositions
```

When the MCMC is run with the `fbseq` function, the package will estimate, for each gene, the probability that each of the 6 propositions is true.

Note: every `Scenario` object has an optional `suppelement` slot with additional information about the scenario. In this case, `paschold@supplement` is an empty list.


## (Optional) create a `Configs` object.

The `Configs` S4 class contains the practical MCMC configuration parameters, such as the number of Monte Carlo iterations and the length of burnin, and important details about model specification. All of them have default settings, so for many simple applications, you should be able to get away with calling the `Configs` function with no arguments. For a full list of slots and their explanations, type `help("Configs-class")`.

## (Optional) create a `Starts` object.

The `Starts` S4 class has the starting values of an MCMC chain. Usually, the user does not need to worry about it, as it is automatically generated for a given dataset and design with `generate_starts` inside the constructor of `Chain` class. However, the user may wish to modify individual slots. For more information, type `help("Starts-class")` and be sure to read the vignette on the hierarchical model.

## Create a `Chain` object.

## Call `fbseq` on the `Chain` object.

## Inspect the output.

# References
